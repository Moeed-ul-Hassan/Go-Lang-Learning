package main

import (
	"context" // Context is used for timeout and cancellation, means if the database is slow or unreachable.
	"fmt"
	"log"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive" // primitive.ObjectID is used to generate unique IDs for documents.
	"go.mongodb.org/mongo-driver/mongo"          // mongo.Connect() is used to connect to the database.
	"go.mongodb.org/mongo-driver/mongo/options"  // options.Client() is used to create a client for the database.
)

/*
User model represents the data structure for our "users" collection.
In MongoDB, we use BSON (Binary JSON) for storage.
The `bson` tags tell the driver how to map Go struct fields to MongoDB document fields.
*/
type User struct {
	// ID is the unique identifier generated by MongoDB.
	// `omitempty` prevents sending an empty ID when creating a new user.
	ID    primitive.ObjectID `json:"id" bson:"_id,omitempty"`
	Name  string             `json:"name" bson:"name"`
	Email string             `json:"email" bson:"email"`
}

// Configuration constants for our database connection.
const connectionString = "mongodb://localhost:27017"
const dbName = "go_mastery"
const colName = "users"

// collection is a package-level variable that holds the reference to our MongoDB collection.
// This allows us to reuse the connection throughout the application.
var collection *mongo.Collection

/*
init() is a special function in Go that runs automatically before main().
We use it here to set up our database connection once when the program starts.
*/
func init() {
	// 1. Define Client Options: Setting the "GPS coordinates" for the database.
	clientOption := options.Client().ApplyURI(connectionString)

	// 2. Create a Context with Timeout: A "safety net" to prevent the app from hanging
	// if the database is slow or unreachable.
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)

	// defer cancel() ensures that the context resources are cleaned up once init() finishes.
	defer cancel()

	// 3. Connect to MongoDB: The initial "handshake" between Go and the database.
	client, err := mongo.Connect(ctx, clientOption)
	if err != nil {
		log.Fatal("Connection Error:", err)
	}

	fmt.Println("MongoDB connection success")

	// 4. Ping the Database: A health check to verify the connection is actually alive.
	err = client.Ping(ctx, nil)
	if err != nil {
		log.Fatal("Could not ping the database:", err)
	}
	fmt.Println("Database ping successful")

	// 5. Initialize the Collection: Pointing our global variable to the specific database and collection.
	collection = client.Database(dbName).Collection(colName)

	fmt.Println("Collection instance is ready")
}

func main() {
	fmt.Println("MongoDB Integration Started")

	// Example: Create a new user instance.
	user := User{
		Name:  "Moeed ul Hassan",
		Email: "moeed@example.com",
	}

	// Call our helper function to insert the user into the database.
	insertUser(user)
}

/*
insertUser is a helper function that takes a User struct and saves it to MongoDB.
*/
func insertUser(user User) {
	// We create a fresh context for this specific operation with a shorter timeout.
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// InsertOne is a driver method that adds a single document to the collection.
	inserted, err := collection.InsertOne(ctx, user)
	if err != nil {
		log.Fatal("Insert Error:", err)
	}

	// InsertedID contains the unique ID generated by MongoDB for this new record.
	fmt.Println("Inserted 1 user with ID:", inserted.InsertedID)
}
